# -*- coding: utf-8 -*-
"""DesafioCandles

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ixRVtewDK1zEVRxhRduYqT0N-t3Au51L
"""

import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import random
from ipywidgets import widgets
from IPython.display import display

# ==== Carregar Dados ====
file_path = '/content/Cópia de Challenge 3_NFLX.xlsx'
df = pd.read_excel(file_path)

# Verificar e adicionar coluna 'Date' se não existir
if 'Date' not in df.columns:
    df['Date'] = pd.date_range(start='2024-01-01', periods=len(df), freq='D')

# ==== Criação de Features ====
df['Body_Percent'] = (df['Close'] - df['Open']) / df['Open'] * 100
df['Upper_Shadow'] = df['High'] - df[['Open', 'Close']].max(axis=1)
df['Lower_Shadow'] = df[['Open', 'Close']].min(axis=1) - df['Low']
df['Upper_Shadow_Ratio'] = df['Upper_Shadow'] / df['Body_Percent']
df['Lower_Shadow_Ratio'] = df['Lower_Shadow'] / df['Body_Percent']
df['Direction'] = np.where(df['Close'] > df['Open'], 'bull', 'bear')

# Remover NaN gerados pelas divisões
df.replace([np.inf, -np.inf], np.nan, inplace=True)
df.dropna(inplace=True)

# ==== Classificação de Corpo (Alto, Médio, Baixo) ====
quantile_75 = df['Body_Percent'].quantile(0.75)
quantile_50 = df['Body_Percent'].quantile(0.50)

def classify_body_size(body_percent):
    if body_percent > quantile_75:
        return 'alto'
    elif body_percent > quantile_50:
        return 'medio'
    else:
        return 'baixo'

df['Body_Size'] = df['Body_Percent'].apply(classify_body_size)

# ==== Classificação da Sombra Predominante e Intensidade ====
quantile_shadow_75 = df[['Upper_Shadow_Ratio', 'Lower_Shadow_Ratio']].quantile(0.75).max()
quantile_shadow_50 = df[['Upper_Shadow_Ratio', 'Lower_Shadow_Ratio']].quantile(0.50).max()
threshold = 0.1  # Ajuste para detectar sombras próximas e criar a classe DS

def classify_shadow(row):
    upper_ratio = row['Upper_Shadow_Ratio']
    lower_ratio = row['Lower_Shadow_Ratio']

    # Classificar a sombra como Dupla, Superior ou Inferior
    if abs(upper_ratio - lower_ratio) < threshold:
        shadow_type = 'dupla'
    elif upper_ratio > lower_ratio:
        shadow_type = 'superior'
    else:
        shadow_type = 'inferior'

    # Classificar a intensidade da sombra
    if max(upper_ratio, lower_ratio) > quantile_shadow_75:
        intensity = 'alta'
    elif max(upper_ratio, lower_ratio) > quantile_shadow_50:
        intensity = 'media'
    else:
        intensity = 'baixa'

    return f"{shadow_type}_{intensity}"

df['Shadow_Class'] = df.apply(classify_shadow, axis=1)

# ==== Criação do Cluster Final ====
df['Final_Cluster'] = df['Direction'] + '' + df['Body_Size'] + '' + df['Shadow_Class']

# ==== Atribuir números para os clusters ====
unique_clusters = df['Final_Cluster'].unique()
cluster_map = {name: idx + 1 for idx, name in enumerate(unique_clusters)}
df['Cluster_Number'] = df['Final_Cluster'].map(cluster_map)

"""Este projeto aplica a segmentação de clusters em dados financeiros com o objetivo de identificar padrões de comportamento de mercado.
Os clusters estão numerados conforme suas características:

- Cluster 1: Alta moderada e baixa volatilidade, indicativo de mercados estáveis.
- Cluster 2: Alta volatilidade e direção ascendente, adequado para estratégias de alto risco.
- Cluster 3: Movimentos de baixa com forte intensidade de queda, interessante para vendas a descoberto.

Critérios de Segmentação:
A segmentação é realizada com base em variações de corpo, sombra superior e inferior, e direção do preço (alta/baixa).
"""

# ==== Definir Cores Dinâmicas para os Clusters ====
def generate_color():
    return "#" + ''.join([random.choice('0123456789ABCDEF') for _ in range(6)])


cluster_colors = {cluster: generate_color() for cluster in unique_clusters}

# ==== Widgets para Seleção de Data ====
date_picker_start = widgets.DatePicker(
    description='Data de Início',
    disabled=False
)
date_picker_end = widgets.DatePicker(
    description='Data de Fim',
    disabled=False
)

def filter_and_plot(b):
    # Obter intervalo de datas
    start_date = pd.to_datetime(date_picker_start.value)
    end_date = pd.to_datetime(date_picker_end.value)

    # Filtrar DataFrame com base no intervalo de datas
    df_filtered = df[(df['Date'] >= start_date) & (df['Date'] <= end_date)].copy()

# ==== Visualização dos Clusters (Candlestick e Boxplots) ====
# Visualizar Candlesticks Clusterizados com Símbolos e Cores
fig = make_subplots(rows=1, cols=1, shared_xaxes=True)

for cluster in df['Final_Cluster'].unique():
    cluster_data = df[df['Final_Cluster'] == cluster]
    symbol = 'triangle-up' if 'bull' in cluster else 'square'
    color = cluster_colors[cluster]

    # Adicionar Candlestick
    fig.add_trace(go.Candlestick(
        x=cluster_data['Date'],
        open=cluster_data['Open'],
        high=cluster_data['High'],
        low=cluster_data['Low'],
        close=cluster_data['Close'],
        name=cluster,
        increasing_line_color=color,
        decreasing_line_color=color
    ))

    # Adicionar Símbolos para Identificar o Cluster
    fig.add_trace(go.Scatter(
        x=cluster_data['Date'],
        y=cluster_data['Low'] - 0.02 * (cluster_data['High'] - cluster_data['Low']),
        mode='markers+text',
        marker_symbol=symbol,
        marker=dict(size=10, color=color),
        text=cluster_data['Cluster_Number'],
        textposition='bottom center',
        name=f'Cluster {cluster}'
    ))

fig.update_layout(
    title='Candlesticks Clusterizados por Final_Cluster com Símbolos e Cores Variadas',
    xaxis_title='Data',
    yaxis_title='Preço',
    xaxis_rangeslider_visible=False
)
fig.show()


# Configuração de layout interativo
fig.update_layout(
    title='Análise de Clusters (Numerada) em Candlesticks',
    xaxis_title='Data',
    yaxis_title='Preço',
    xaxis_rangeslider_visible=False,
    updatemenus=[{
        "buttons": [
            {"label": "Todos", "method": "update", "args": [{"visible": [True] * len(df['Cluster_Number'].unique())}]},
            {"label": "Cluster 1", "method": "update", "args": [{"visible": [cluster == 1 for cluster in df['Cluster_Number']]}]},
            {"label": "Cluster 2", "method": "update", "args": [{"visible": [cluster == 2 for cluster in df['Cluster_Number']]}]},
            {"label": "Cluster 3", "method": "update", "args": [{"visible": [cluster == 3 for cluster in df['Cluster_Number']]}]},
            {"label": "Cluster 4", "method": "update", "args": [{"visible": [cluster == 4 for cluster in df['Cluster_Number']]}]},
            {"label": "Cluster 5", "method": "update", "args": [{"visible": [cluster == 5 for cluster in df['Cluster_Number']]}]},
            {"label": "Cluster 6", "method": "update", "args": [{"visible": [cluster == 6 for cluster in df['Cluster_Number']]}]},
            {"label": "Cluster 7", "method": "update", "args": [{"visible": [cluster == 7 for cluster in df['Cluster_Number']]}]},
            {"label": "Cluster 8", "method": "update", "args": [{"visible": [cluster == 8 for cluster in df['Cluster_Number']]}]},
            {"label": "Cluster 9", "method": "update", "args": [{"visible": [cluster == 9 for cluster in df['Cluster_Number']]}]},
            {"label": "Cluster 10", "method": "update", "args": [{"visible": [cluster == 10 for cluster in df['Cluster_Number']]}]},
            {"label": "Cluster 11", "method": "update", "args": [{"visible": [cluster == 11 for cluster in df['Cluster_Number']]}]},
            {"label": "Cluster 12", "method": "update", "args": [{"visible": [cluster == 12 for cluster in df['Cluster_Number']]}]},
            {"label": "Cluster 13", "method": "update", "args": [{"visible": [cluster == 13 for cluster in df['Cluster_Number']]}]},
            {"label": "Cluster 14", "method": "update", "args": [{"visible": [cluster == 14 for cluster in df['Cluster_Number']]}]},


        ],
        "direction": "down",
        "showactive": True,
    }]
)

fig.show()

# Boxplot para Body_Percent por Cluster
fig_body = px.box(df, x="Final_Cluster", y="Body_Percent", color="Final_Cluster",
                  title="Distribuição de Body_Percent por Cluster",
                  labels={"Final_Cluster": "Cluster", "Body_Percent": "Variação do Corpo (%)"},
                  color_discrete_map=cluster_colors)
fig_body.update_layout(showlegend=False)
fig_body.show()

# Boxplot para Upper_Shadow_Ratio por Cluster
fig_upper_shadow = px.box(df, x="Final_Cluster", y="Upper_Shadow_Ratio", color="Final_Cluster",
                          title="Distribuição da Razão da Sombra Superior por Cluster",
                          labels={"Final_Cluster": "Cluster", "Upper_Shadow_Ratio": "Razão da Sombra Superior"},
                          color_discrete_map=cluster_colors)
fig_upper_shadow.update_layout(showlegend=False)
fig_upper_shadow.show()

# Boxplot para Lower_Shadow_Ratio por Cluster
fig_lower_shadow = px.box(df, x="Final_Cluster", y="Lower_Shadow_Ratio", color="Final_Cluster",
                          title="Distribuição da Razão da Sombra Inferior por Cluster",
                          labels={"Final_Cluster": "Cluster", "Lower_Shadow_Ratio": "Razão da Sombra Inferior"},
                          color_discrete_map=cluster_colors)
fig_lower_shadow.update_layout(showlegend=False)
fig_lower_shadow.show()